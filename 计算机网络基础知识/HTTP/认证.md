# 8、确认用户身份的认证

为了确认正在访问服务器的人是否为本人，需要核对本人才知道的信息，本人才会有的信息。

`HTTP`使用的认证方式

- `BASIC`认证(基本认证)
- `DIGEST`认证(数字认证)
- `SSL`客户端认证
- `FormBase`认证(基于表单认证)

此外，还有`Keberos`认证等。

## 8.1、`BASIC`认证

> `BASIC`认证是`HTTP/1.0`定义的认证方式。

`BASIC`认证的过程：

1. 客户端发送请求，当请求的资源需要`BASIC`认证时，服务器会返回`401`状态码，并返回`WWW-Authenticated`首部字段，该字段包含需要的认证方式和安全域字符串`realm`。
2. 接收到`401`的客户端，将用户ID和密码发送给服务器，发送的字符串内容由用户ID和密码构成，以冒号`:`连接，再经过`Base64`编码处理。在浏览器中，转`Base64`可能会由浏览器自动完成。
3. 接收到包含首部字段`Authorization`的请求后，服务器会进行验证，如果验证通过，则会返回状态码`200`以及对应请求资源的响应，若认证失败仍然返回`401`。

`BASIC`认证的不足：
1. `Base64`不是加密处理，可轻松解码，其中包括用户ID和密码，容易被窃听。
2. 一般的浏览器无法实现认证注销操作。
3. 达不到多数`Web`网站期望的安全性等级。

## 8.2、`DIGEST`认证

> `DIGEST`认证：为了弥补`BASIC`认证的不足，从`HTTP/1.1`中引入了`DIGEST`认证，采用`质问/响应`的方式。


`DIGEST`认证的流程：

1. 客户端请求需要认证的资源时，服务器返回`401`，并返回`WWW-Authenticated`首部字段，包含质问响应方式认证所需要的`临时质询码`(随机数，`nonce`)，且包含`realm`。
2. 客户端接收到`401`后，返回的认证需要包含`Authorization`首部字段，需要包含`username`，`realm`，`nonce`，`uri`和`response`字段信息，其中`realm`和`nonce`就是之前从服务器接收到的响应中的字段。`response`存放的是经过`MD5`运算后的密码字符串，形成响应码。
3. 服务端在接收到包含首部字段`Authorization`的请求之后，会确认认证信息的正确性。认证通过之后会返回响应的资源，认证失败则再次返回`401`。


`DIGEST`认证的优势与不足：
1. 采用`质询/响应`的方式，不会像`BASIC`认证那样直接发送明文密码。
2. 安全等级比`BASIC`认证高，但是比`HTTPS`认证低。

## 8.3、SSL客户端认证


> `SSL`客户端认证：借由`HTTPS`的客户端证书完成认证的方式。`SSL`客户端认证可以避免用户名和密码被盗取后，第三者冒充的情况。


`SSL`客户端认证的过程（为了达到认证目的，需要先将客户端证书发给客户，客户进行安装）：

1. 接收到需要认证资源的请求，服务器会发送`Certificate Request`报文，要求客户端提供客户端证书。
2. 用户选择将要发送的客户端证书后，客户端会将客户端证书以`Client Certificate`报文方式发送给服务器。
3. 服务器验证客户端证书之后，即可以领取证书内客户端的公开密钥，然后开始`HTTPS`通信。

`SSL`客户端认证的特点：
- 客户端证书需要支付一定的费用。
- `SSL`客户端认证一般会和基于表单认证组合成一种双因素认证来使用。`SSL`客户端认证来认证客户端计算机，表单认证用来确定是用户本人的行为。


## 8.4、基于表单认证

> 基于表单认证：客户端会向服务器上的`Web`应用程序发送登录信息，按照登录信息的验证结果验证。 

`HTTP`协议提供的`BASIC`认证和`DIGEST`认证一般不怎么使用，且`SSL`客户端认证由于费用等问题，也尚未普及。对于`Web`网站的认证功能，能够满足安全使用级别的标准规范不存在，只好由`Web`应用程序各自实现基于表单的认证方式。不同的Web应用程序实现各自的基于表单的认证方式。有不同的实现方式。

基于表单认证一般会使用`Cookie`来管理会话`Session`，其本身是通过服务器端的`Web`应用，将客户端发送过来的用户`ID`和密码与之前登录过的信息做匹配来进行认证的。

基于表单认证的过程：
1. 客户端把用户ID和密码放入报文的实体，通常以`POST`形式把请求发送给服务器。这时会以`HTTPS`通信来进行`HTML`表单画面的显示和用户输入数据的发送。
2. 服务器会发放用以识别用户的`SessionID`。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与`SessionID`绑定后记录在服务器端。向客户端返回响应时，会在首部字段`Set-Cookie`内写入`SessionID`。
3. 客户端在接收到从服务器发来的`SessionID`之后，会将其作为`Cookie`保存在本地。下次向服务器发送请求时，会自动发送`Cookie`，所以其`SessionID`会随之发到服务器。
4. 服务器端可以通过验证接收到的`SessionID`识别用户和其认证状态。

`SessionID`就是用来区分不同用户的等位号。基于表单认证也有除了上面以外的其他方法案例。

基于表单认证的登录信息以及认证过程无标准化的方法，而且服务器端保存用户名，密码等信息这个流程也没有标准化，其中一种安全的方法是给密码加盐，增加密码的额外信息，再使用`hash`计算散列值之后保存。
